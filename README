At this point, this is a demo implementation of the Fractal Flame algorithm described in Scott Draves' paper http://flam3.com/flame.pdf

I put it together as an independently researched, defined, and implemented final project for my computer graphics class in college.  Excerpt from the accompanying report:
I completed the random walk algorithm to find the fixed point of a set of functions, and built (program) functions and data structures to represent the structure of the composed functions described in the paper.  In doing this I noticed that under certain parameter sets points outside the [-1.0,1.0] square onto which the plot was imposed were generated; this was accommodated by trying to choose parameters that kept most points inside the plotted region but allowed the algorithm to continue when outside points were generated, simply discarding them.  This changes the level of detail from frame to frame slightly, but the difference is not as far as I can tell noticeable visually.  
	Once the plotting algorithm was well-established, I moved on to display refinements.  The first step was applying a logarithmic scale to the grayscale histogram generated by plotting points and coloring corresponding pixels; originally I used a linear scale of the histogram values to determine pixel brightness, but this didn't represent image detail very well.  This and all subsequent beautification measures were directly taken from the paper.  Next came adding color.  This involved obtaining a color palette (I adapted one from an existing sheep) and writing functions to map floating point color indices associated with functions to colors in the palette.  The math for logarithmically scaling each pixel's channels taking into consideration the number of plots each pixel received (rather than exclusively using the maximum number of plots any pixel received â€“ the approach I used for grayscale) was tricker than the paper suggested and I spent more time than I'd expected to getting that right.  Afterwards, gamma correction and vibrancy, which are very much related to one-another and the approach to color scaling I'd just implemented, were comparatively easy to figure out despite their cursory treatment in the paper.  
	I didn't get to  symmetry, basic anti-aliasing, motion blur, or temporal motion blur.  I'd also like to figure out how to use existing Open Source XML parsing libraries, which are readily available, to read the files used by Electric Sheep to describe individual sheep and render them at least approximately in the same way the standard implementation would.  Additionally, I have at this point only coded 6 of the 49 nonlinear variational functions defined in the paper; this reduced selection clearly limits what my sheep can do.  I also make no use of linear post transformations, final nonlinear transformations, or varying nonlinear variational function coefficients between different main functions, although my function evaluation system is perfectly capable of doing all of these things.  I also did no research whatsoever as to how one might set any sheep parameters in interesting or meaningful ways, especially with regard to animation.  What I have arrived at insofar is completely the result of trial and error setting parameters randomly and restricting the set of parameters in use.  There is definitely some reading to be done on the subject.  Although most of the variables that affect the outcome of rendering are centralized in engine.c, functions.c, and to a limited extent in color_palette.c, I'd like to expand this system to take parameters from a file as mentioned above or at least from the command line, so recompilation isn't necessary in order to change the appearance of a sheep.

See install for build instructions.
